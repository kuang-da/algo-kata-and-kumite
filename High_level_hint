1，一般来说，贪心的时间复杂度在O(n)，空间复杂度是O(1) 或 O(n) 。
2，动规需要记录表（标记数组），时间复杂度经常是O(n^2)，空间复杂度也通常是O(n^2) 。
3，回溯很常见，重点是确定何时找到一个解、何时退出、越界时如何处理；通常需要一个线性结构来保存前面的状态，以便回溯时使用。
4，如果贪心、动规等方法都行不通，通常就考虑搜索来解决。
5，线性时间复杂度一般通过贪心方法实现；有时候，需要借助HASH结构（如unordered_map）。
6，利用好栈(stack)！很多问题通过栈能够在O(n) 时间内解决。
7，深度优先搜索一般是递归的，数据过大时，递归深度太大出现问题；广度优先搜索一般借助队列，一般不需要递归。
8，初始化数组时，memset(address, value, n_bytes) (包含在cstring.h) 是针对“字节”赋值！所以除非是单字节元素，或者初值为0或者-1，否则不要用memset 初始化；使用vector 比较方便。
9，必要时，使用unordered_map, unordered_set 等C++ 容器。
10，必要时，利用类变量简化传参。
11，动规的关键是找到转移方程；因此动规的子问题具有“累积”性质。
12，贪心不同于动规，贪心的子问题不是“累积性“，而是具有“决定性”。
13，写代码最重要的是思路清楚、可理解性，而不是纠结变量少、代码短等无关紧要的问题。
14，由于单链表只能从前向后遍历，因此操作时经常需要保存所关心结点的前趋结点。
15，处理链表要时刻注意检查空指针NULL。
16，数组检索、定位快；链表插入、删除快（不需要移动数据）。
17，vector, string 的性质都倾向于数组；List 的性质倾向于链表。
18，二叉树问题的基础是遍历方法：前序/中序/后续，递归与非递归都很重要。
19，关于二叉树的问题，有些是自顶向下的；也有些是自底向上的，如检查平衡二叉树。通常这两类问题都可以通过递归、非递归两种方法解决。
20，二叉树非递归遍历：前序遍历最简单，当前结点没有左儿子时，栈顶就是下一个结点；中序遍历需要先将当前结点（顶点）入栈，当前结点没有左儿子时，访问栈顶，并且栈内结点的头一个非空右儿子是下一个结点；后序遍历最后访问根结点，所以，顶点不仅要入栈，而且要记录是否访问了它的右儿子，只有访问了顶点的右儿子之后才能访问它自己。
21，许多问题需要应用二叉树遍历方法，有些问题需要在结点入栈的同时保存当前状态（如求最长路径）。
22，二叉树Level 遍历的本质是广度优先搜索，需要利用队列。
23，关于”图“，LeetCode 只有一道遍历题目，需要到其他地方补充一下。
24，有些方法虽然AC 了，但并不一定是最优美的。